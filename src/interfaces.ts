type IterableElement<T> =
  T extends Iterable<infer Element> ? Element
  : T extends AsyncIterable<infer Element> ? Element
  : never;

/**
 * Convert first character of string literal type to uppercase and the rest to
 * lowercase
 */
type Sentencize<S extends string> = Capitalize<Lowercase<S>>;

/**
 * A labeled tuple of valid keys and values from a type `T` with an index
 * signature
 */
type Entry<T extends Record<PropertyKey, unknown>> = [
  key: keyof T,
  value: T[keyof T],
];

/**
 * In C, enums were not allowed to have a value that was not an `int` until the
 * C23 standard. In C++ enums, strongly typed enums were introduced in C++11. By
 * default, as of clang v21.0.0, the C standard is C17 and the C++ standard is
 * C++17.
 *
 * Regardless, Emscripten's Embind currently only allows values of at most `int`
 * in enums, so `T extends number` would be accurate. However, for flexibility,
 * `T extends unknown` for now
 *
 * @see {@link https://open-std.org/JTC1/SC22/WG14/www/docs/n3029.htm}
 * @see {@link https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2347.pdf}
 * @see {@link https://github.com/emscripten-core/emscripten/blob/main/system/include/emscripten/bind.h#L2230-L2240}
 */
type EmbindEnumValue<T> = { value: T };

/**
 * An enum binding generated by Emscripten's Embind. It has a `typeof` of
 * "function" and maps the enum keys to an function where its `.value` property
 * is the corresponding value of the enum key
 *
 * @remarks While this is not shown in the generated TypeScript definitions or
 * stated in the documentation, the generated enums also have two additional
 * properties: `argCount` (0) and `values`, which seems to be a reverse mapping
 * of the enum values to a `.value` property of itself
 */
type EmbindEnum<T extends Record<PropertyKey, unknown>> = {
  [Key in keyof T]: EmbindEnumValue<T[Key]>;
};

export type { IterableElement, Sentencize, Entry, EmbindEnumValue, EmbindEnum };
